/*
Breadth first search: bfs is for traversing or searching tree or graph data structures.
It uses a queue instead of a stack and it checks whether a vertex has been discovered 
before enqueueing the vertex rather than delaying this check until the vertex is dequeued 
from the queue.

Example(http://poj.org/problem?id=2386):
Due to recent rains, water has pooled in various places in Farmer John's field, which is 
represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square 
contains either water ('W') or dry land ('.'). Farmer John would like to figure out how 
many ponds have formed in his field. A pond is a connected set of squares with water in 
them, where a square is considered adjacent to all eight of its neighbors. 

Given a diagram of Farmer John's field, determine how many ponds he has.

Input:
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
Output
3
*/
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
using namespace std;

#define N 110
struct Node
{
    int x,y;
};

char Map[N][N];
bool Vis[N][N];
int dir[10][3]={ {0,1},{0,-1},{-1,0},{1,0},{-1,-1},{-1,1},{1,-1},{1,1} };
int row, col;

bool IsInMap(int r, int c)
{
    if(r >= 1 && r <= row && c >= 1 && c <= col){
        return  true;
    }
    return  false;
}

void BFS(int x, int y)
{
    Node NextNode;
    Node CurrentNode;
    CurrentNode.x = x;
    CurrentNode.y = y;
	
    queue<Node> q;
    q.push(CurrentNode);
    Vis[x][y] = true;
    while(!q.empty()){
        CurrentNode = q.front();
        q.pop();
        for(int i = 0; i < 8; i++){
            NextNode.x = CurrentNode.x + dir[i][0];
            NextNode.y = CurrentNode.y + dir[i][1];
            if(Map[NextNode.x][NextNode.y] == 'W' && !Vis[NextNode.x][NextNode.y] 
              && IsInMap(NextNode.x, NextNode.y)){			    	
                q.push(NextNode);
                Vis[NextNode.x][NextNode.y] = true;
            }
        }
    }
}

int main()
{
    int ans = 0;
    while(~scanf("%d%d", &row, &col))
    {
        memset(Vis, false, sizeof(Vis));
        getchar();
        ans = 0;
        for(int i = 1; i <= row; i++){
            for(int j = 1; j<= col; j++){
                scanf("%c", &Map[i][j]);
	    }  
            getchar();
	}
        for(int i = 1; i <= row; i++){
            for(int j = 1; j <= col; j++){
                if(Map[i][j] == 'W' && !Vis[i][j]){
                    BFS(i,j);
                    ans++;
                }
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}

/*
If a graph contains a "negative cycle" (a cycle whose edges sum to a negative value) that 
is reachable from the source, then there is no cheapest path: any path that has a point on 
the negative cycle can be made cheaper by one more walk around the negative cycle. In such 
a case, the Bellman–Ford algorithm can detect negative cycles and report their existence.

Like Dijkstra's Algorithm, Bellman–Ford is based on the principle of relaxation, in which an 
approximation to the correct distance is gradually replaced by more accurate values until eventually 
reaching the optimum solution. In both algorithms, the approximate distance to each vertex is always
an overestimate of the true distance, and is replaced by the minimum of its old value with the length 
of a newly found path. However, Dijkstra's algorithm uses a priority queue to greedily select the 
closest vertex that has not yet been processed, and performs this relaxation process on all of its 
outgoing edges; by contrast, the Bellman–Ford algorithm simply relaxes all the edges, and does this 
|V|-1 times, where |V| is the number of vertices in the graph. In each of these repetitions, the number 
of vertices with correctly calculated distances grows, from which it follows that eventually all vertices 
will have their correct distances. This method allows the Bellman–Ford algorithm to be applied to a wider 
class of inputs than Dijkstra.

Bellman–Ford runs in O(|V|\cdot |E|) time, where |V| and |E| are the number of vertices and edges respectively.
*/
const int inf = 999999;
struct Edge 
{

    int u,v;//two points of a edge
    int w;//weight

}edge[1000];
int dis[100];
int edgeNum;
void Init(int v)
{
    for(int i = 0; i <= n; i++){
        dis[i] = inf;
    }
    dis[v] = 0;
}
bool BellMan()
{
    bool flag;
    for(int i = 0; i < n - 1; i++){
        flag = false;
        for(int j = 0; j < edgeNum; j++){
            if (dis[edge[j].v] > dis[edge[j].u] + edge[j].w){
                dis[edge[j].v] = dis[edge[j].u] + edge[j].w;
                flag = true;
            }
        }
        if (!flag){//exist negative edge
            break;
        }
    }
    for(int i = 0; i < edgeNum; ++ i){
        if(dis[edge[i].v] > dis[edge[i].u] + edge[i].w){
            return true;
        }
    }
    return false;
}
